"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const Config_1 = require("./../../Config");
const realm_utils_1 = require("realm-utils");
const Utils_1 = require("../../Utils");
class CSSPluginClass {
    constructor(opts = {}) {
        this.test = /\.css$/;
        this.minify = false;
        this.options = opts;
        if (opts.minify !== undefined) {
            this.minify = opts.minify;
        }
    }
    init(context) {
        context.allowExtension(".css");
    }
    bundleStart(context) {
        let lib = path.join(Config_1.Config.FUSEBOX_MODULES, "fsbx-default-css-plugin", "index.js");
        context.source.addContent(fs.readFileSync(lib).toString());
    }
    inject(file, options, alternative) {
        const resolvedPath = realm_utils_1.utils.isFunction(options.inject)
            ? options.inject(file.info.fuseBoxPath) : file.info.fuseBoxPath;
        const result = options.inject !== false ? `__fsbx_css("${resolvedPath}");` : "";
        if (alternative) {
            file.addAlternativeContent(result);
        }
        else {
            file.contents = result;
        }
    }
    transformGroup(group) {
        const debug = (text) => group.context.debugPlugin(this, text);
        debug(`Start group transformation on "${group.info.fuseBoxPath}"`);
        let concat = new Utils_1.Concat(true, "", "\n");
        group.subFiles.forEach(file => {
            debug(`  -> Concat ${file.info.fuseBoxPath}`);
            concat.add(file.info.fuseBoxPath, file.contents, file.generateCorrectSourceMap());
        });
        let options = group.groupHandler.options || {};
        const cssContents = concat.content;
        if (options.outFile) {
            let outFile = Utils_1.ensureUserPath(options.outFile);
            const bundleDir = path.dirname(outFile);
            const sourceMapsName = path.basename(outFile) + ".map";
            concat.add(null, `/*# sourceMappingURL=${sourceMapsName} */`);
            debug(`Writing ${outFile}`);
            return Utils_1.write(outFile, concat.content).then(() => {
                this.inject(group, options);
                const sourceMapsFile = Utils_1.ensureUserPath(path.join(bundleDir, sourceMapsName));
                return Utils_1.write(sourceMapsFile, concat.sourceMap);
            });
        }
        else {
            debug(`Inlining ${group.info.fuseBoxPath}`);
            const safeContents = JSON.stringify(cssContents.toString());
            group.addAlternativeContent(`__fsbx_css("${group.info.fuseBoxPath}", ${safeContents});`);
        }
        this.emitHMR(group);
    }
    emitHMR(file) {
        let emitRequired = true;
        const bundle = file.context.bundle;
        if (bundle && bundle.lastChangedFile) {
            emitRequired = Utils_1.isStylesheetExtension(bundle.lastChangedFile);
        }
        if (emitRequired) {
            file.context.sourceChangedEmitter.emit({
                type: "js",
                content: file.alternativeContent,
                path: file.info.fuseBoxPath,
            });
        }
    }
    transform(file) {
        if (file.hasSubFiles()) {
            return;
        }
        const debug = (text) => file.context.debugPlugin(this, text);
        file.loadContents();
        let filePath = file.info.fuseBoxPath;
        let context = file.context;
        file.contents = this.minify ? this.minifyContents(file.contents) : file.contents;
        if (this.options.group) {
            file.sourceMap = undefined;
            const bundleName = this.options.group;
            let fileGroup = context.getFileGroup(bundleName);
            if (!fileGroup) {
                fileGroup = context.createFileGroup(bundleName, file.collection, this);
            }
            fileGroup.addSubFile(file);
            debug(`  grouping -> ${bundleName}`);
            file.addAlternativeContent(`require("~/${bundleName}")`);
            return;
        }
        let outFileFunction;
        if (this.options.outFile !== undefined) {
            if (!realm_utils_1.utils.isFunction(this.options.outFile)) {
                context.fatal(`Error in CSSConfig. outFile is expected to be a function that resolves a path`);
            }
            else {
                outFileFunction = this.options.outFile;
            }
        }
        if (outFileFunction) {
            const userPath = Utils_1.ensureUserPath(outFileFunction(file.info.fuseBoxPath));
            this.inject(file, this.options, true);
            return Utils_1.write(userPath, file.contents).then(() => {
                if (file.sourceMap) {
                    const fileDir = path.dirname(userPath);
                    const sourceMapPath = path.join(fileDir, path.basename(userPath) + ".map");
                    return Utils_1.write(sourceMapPath, file.sourceMap).then(() => {
                        file.sourceMap = undefined;
                    });
                }
            });
        }
        else {
            let safeContents = JSON.stringify(file.contents);
            file.sourceMap = undefined;
            file.addAlternativeContent(`__fsbx_css("${filePath}", ${safeContents})`);
            this.emitHMR(file);
        }
    }
    minifyContents(contents) {
        return contents.replace(/\s{2,}/g, " ").replace(/\t|\r|\n/g, "").trim();
    }
}
exports.CSSPluginClass = CSSPluginClass;
exports.CSSPlugin = (opts) => {
    return new CSSPluginClass(opts);
};
